package edu.brown.cs.student.main.models.markov;

import com.squareup.moshi.Json;
import edu.brown.cs.student.main.RandomGenerator;
import edu.brown.cs.student.main.models.exceptions.InvalidDistributionException;
import java.util.HashMap;
import java.util.Objects;
import java.util.Set;
import java.util.UUID;

/**
 * The HiddenState class, which models a hidden state in the hidden markov model that MarkovModel represents.
 * In particular, this class contains a state distribution (for transitioning) and an emission distribution
 * (for outputting workouts). When MarkovModel runs, it has its current HiddenState emit a workout based
 * on its distribution, and then transition.
 */
public class HiddenState {

  private final HashMap<HiddenState, Double> transitionDistribution;
  private final HashMap<Emission, Double> emissionDistribution;
  private final String name;

  /**
   * The constructor for the HiddenState class, which takes in the name of the state, its transitions, and
   * its emission distribution.
   *
   * @param name - the name of the state.
   * @param transitionDistribution - the transition distribution of the state.
   * @param emissionDistribution - the emission distribution of the state.
   */
  public HiddenState(
      @Json(name = "category") String name,
      @Json(name = "transitions") HashMap<HiddenState, Double> transitionDistribution,
      @Json(name = "emissions") HashMap<Emission, Double> emissionDistribution) throws InvalidDistributionException {
    if (transitionDistribution == null || emissionDistribution == null) {
      throw new InvalidDistributionException("Missing one of the distributions when generating a hidden state (null).",
              new HashMap());
    }
    this.transitionDistribution = transitionDistribution;
    this.emissionDistribution = emissionDistribution;
    this.name = name;
  }

  /**
   * This method emits a workout from the HiddenState's emission distribution.
   *
   * @return the emitted workout.
   * @throws InvalidDistributionException if the emission distribution is not a valid distribution.
   */
  public Emission emit() throws InvalidDistributionException {
    RandomGenerator.validateDistribution(Emission.class, this.emissionDistribution);
    return RandomGenerator.generateRandomFromDistribution(
        Emission.class, this.emissionDistribution);
  }

  /**
   * This method returns the resulting HiddenState from a transition call, as generated by the
   * transition distribution.
   *
   * @return the transitioned HiddenState.
   * @throws InvalidDistributionException if the transition distribution was not valid.
   */
  public HiddenState transition() throws InvalidDistributionException {
    RandomGenerator.validateDistribution(HiddenState.class, this.transitionDistribution);
    return RandomGenerator.generateRandomFromDistribution(
        HiddenState.class, this.transitionDistribution);
  }

  /**
   * Returns the set of potential hidden states this state can transition to. Should be equal to
   * the list of states in a given model (i.e. has defined probabilities for all other states in the
   * model).
   * @return the set of potential states to transition to.
   */
  public Set<HiddenState> potentialStates() {
    return this.transitionDistribution.keySet();
  }

  /**
   * Adds a new transition to the transition distribution. Safe, as the distribution is always
   * verified before it is used. Must be used cautiously; fillTransitions is preferred (and safer).
   *
   * @param state - the state to add a transition to.
   * @param prob - the probability of transition to the new state.
   */
  public void addTransition(HiddenState state, Double prob) {
    this.transitionDistribution.put(state, prob);
  }

  /**
   * This method replaces the current transition distribution with the new one passed in.
   *
   * @param transitions - the new distribution of transitions.
   * @throws InvalidDistributionException if the new distribution is not valid.
   */
  public void fillTransitions(HashMap<HiddenState, Double> transitions)
      throws InvalidDistributionException {
    RandomGenerator.validateDistribution(HiddenState.class, transitions);
    this.transitionDistribution.clear();
    for (HiddenState key : transitions.keySet()) {
      this.transitionDistribution.put(key, transitions.get(key));
    }
  }

  /**
   * Adds a new emission to the emission distribution. Safe, as the distribution is always
   * verified before it is used. Must be used cautiously; fillEmissions is preferred (and safer).
   *
   * @param emission - the emission to add to the distribution.
   * @param prob - the probability of emitting the new emission.
   */
  public void addEmission(Emission emission, Double prob) {
    this.emissionDistribution.put(emission, prob);
  }

  /**
   * This method replaces the current emission distribution with the new one passed in.
   *
   * @param emissions - the new distribution of emissions.
   * @throws InvalidDistributionException if the new distribution is not valid.
   */
  public void fillEmissions(HashMap<Emission, Double> emissions)
      throws InvalidDistributionException {
    RandomGenerator.validateDistribution(Emission.class, emissions);
    this.emissionDistribution.clear();
    for (Emission key : emissions.keySet()) {
      this.emissionDistribution.put(key, emissions.get(key));
    }
  }

  /**
   * A method for verifying that a given state has both of its distributions valid at a given point
   * in time.
   *
   * @throws InvalidDistributionException if either of the distributions (emission or transition) is
   * not valid.
   */
  public void checkDistributions() throws InvalidDistributionException {
    RandomGenerator.validateDistribution(HiddenState.class, this.transitionDistribution);
    RandomGenerator.validateDistribution(Emission.class, this.emissionDistribution);
  }

  /**
   * Overridden equals method, so each HiddenState is compared on the basis of its fields.
   * Uses flattened transition distribution (keys on HiddenState names instead of HiddenStates)
   * to avoid infinitely looping when verifying two HiddenStates are equal.
   *
   * @param o - the object to check equality with.
   * @return true if this instance is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }
    HiddenState that = (HiddenState) o;

    return Objects.equals(this.emissionDistribution, that.emissionDistribution)
        && Objects.equals(this.name, that.name)
        && Objects.equals(this.flattenTransitionDist(), that.flattenTransitionDist());
  }

  /**
   * Overridden toString method, so all fields of a HiddenState are printed when it is printed.
   *
   * @return the string version of a HiddenState.
   */
  @Override
  public String toString() {
    return "HiddenState{"
        + "transitionDistribution="
        + this.flattenTransitionDist()
        + ", emissionDistribution="
        + this.emissionDistribution
        + ", name='"
        + this.name
        + '\''
        + '}';
  }

  /**
   * A helper method for reducing the transition distribution to key on HiddenState names, rather
   * than HiddenStates themselves. Helps avoid infinite loops when trying to see if two HiddenStates
   * are equal.
   *
   * @return - the flatted transition distribution.
   */
  private HashMap<String, Double> flattenTransitionDist() {
    HashMap<String, Double> flattenedDistThis = new HashMap<>();
    for (HiddenState key : this.transitionDistribution.keySet()) {
      flattenedDistThis.put(key.name, this.transitionDistribution.get(key));
    }
    return flattenedDistThis;
  }
}
